class SocketManager;
	poll();
	add_socket(int *socket_users_poll_idx);
	/* single array to only use one poll for all sockets */
	std::vector<struct pollfd>		pollfds;
	std::vector<bool>				too_close;
	std::vector<int*>				socket_users_poll_idx;

	process_closures();
		for N >= 0 < pollfds.size()
		if (too_close[N])
			close(N)
	close(N);
		socket_users_poll_idx[N]: INVALID
		close(pollfds[N]);
		pollfds[N] = pollfds.end() - 1
		too_close[N] = too_close.end() - 1;
		socket_users_poll_idx[N] = socket_users_poll_idx.too_close.end() - 1
		*socket_users_poll_idx[N] = N
		pollfds.pop_back();
		too_close.pop_back();
		socket_users_poll_idx.pop_back();


Data std::vector<Server>			servers;
	Server

socket_user
	Server
	Client

Class Server(config);
	int					poll_fd_idx;
	close_later();
	Config				config;
	accept_clients();
	process_clients();
	read_files();
	write_files();
	std::list<Client>	clients;

Class Client(Server);
	int					poll_fd_idx;
	init();
	close_later();
	Server&				server;
	ClientMode			mode;
	process();
		reseive();
			Request				request;
		respond();
			Response			response;
		re_init();
	

Enum ClientMode;
	RESEIVING;
	SENDING;

Class Request;
	std::string	input;
	Parser		parser;
	parsed_input;

class Parser;

struct parsed_input;

Class Respond(parsed_input);
	execute

init;
{
	SocketManager;
	servers;
}

main_loop;
{
	SocketManager.poll()
	for server : servers {
		accept_clients();
		resive();
		read_files();
		respond();
	}
	SocketManager.process_closures();
}
